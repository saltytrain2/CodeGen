	As with the Semantic Analyzer, the first step of the Code Generator was deserializing the input generated by the Type Checker. While we were able to reuse the AST Nodes from the previous assignment, we created new node types representing entries in the parent, implementation, and class maps. Creating these new node types simplified parsing of the annotated syntax tree, and we used these nodes as inputs to the rest of the compiler.
	Once the maps were deserialized, we designed a three address code to serve as the IR between the annotated AST Nodes and the actual machine instructions. The three address code was designed to be as close to the eventual machine instructions as possible. For example, instead of having a TAC add instruction that added two boxed Integer types, our TAC add instruction adds two primitive integers values together. The format of the TAC is also loosely based on SSA TAC forms, which is the concept of assigned to virtual registers only once. While our TAC is not completely SSA compliant since we do repeatedly assign to memory locations, having normal operations be SSA compliant made subsequent parts of the compiler easier to manage. After creating the TAC and translating from the AST Nodes to their TAC representation, we then took each function and generated a control flow graph. The control flow graph allowed us to break each function into its BasicBlock and perform a liveness analysis, which we then used to perform a register allocation. This is where the SSA compliance became handy, as it limited the register pressure, allowing us to generate code for most of the test cases that fit exclusively inside the 8 caller-saved registers. After performing the register allocation, we could finally linearly traverse each TAC instruction in order and generate the resultant x86 code.
	On hindsight, there were several design decisions that we made that could have been better. First, we probably should have created a stack machine code generator. We created a CFG and made a register allocator for this assignment because we belived that it give us a head start on PA6, but it took much longer to get code generated using a register allocator. As a result, we spent much longer on this assignment trying to fix bugs than intended. Introducing a register allocator and a CFG meant that when it came down to debug our x86 files, we had to determine whether the bug resided in our TAC generation, our x86 code generation, or the processing of our CFG. In a normal stack machine generator, we would only have to worry about TAC generation and x86 generation, resulting in a less complex system that is easier to debug. 
	We submit 4 test cases that exercise different parts of the compiler. Test1 targets the standard library, making sure the builtin cool methods were correct. Test2 targets scoping and lets, where this test case exposed a bug in our compiler when updating the symbol table too early. Test3 is another binary tree application that tests dispatch on void errors using the return value from a while loop. Finally, Test4 covers object comparison and case expressions, making sure that the compiler correct accounts for entering the correct case branch.
